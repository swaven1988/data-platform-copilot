from __future__ import annotations

from typing import Dict, Literal, Optional
from pydantic import BaseModel, Field, field_validator

Language = Literal["pyspark", "scala"]
WriteMode = Literal["merge", "append", "overwrite"]
Preset = Literal["generic", "enterprise_a", "enterprise_b"]


class CopilotSpec(BaseModel):
    # Identity
    job_name: str = Field(..., min_length=1, pattern=r"^[a-zA-Z0-9_\-]+$")
    preset: Preset = "generic"

    # Runtime / scheduling
    owner: str = "data-platform"
    env: str = "dev"
    schedule: str = "0 6 * * *"
    timezone: str = "UTC"
    description: str = "Example Spark pipeline generated by Copilot"
    tags: list[str] = Field(default_factory=lambda: ["copilot", "dev"])

    # IO
    source_table: str = "raw_db.source_table"
    target_table: str = "curated_db.target_table"
    partition_column: str = "data_dt"
    write_mode: WriteMode = "merge"

    # Language
    language: Language = "pyspark"

    # Spark config
    spark_dynamic_allocation: bool = True
    spark_conf_overrides: Dict[str, str] = Field(default_factory=dict)

    # Optional “future” hooks (kept for enterprise refinements)
    dq_enabled: bool = False
    troubleshoot_enabled: bool = False

    @field_validator("schedule")
    @classmethod
    def _basic_cron_sanity(cls, v: str) -> str:
        # keep it simple: 5-field cron expected for now
        parts = v.strip().split()
        if len(parts) != 5:
            raise ValueError("schedule must be a 5-field cron expression (e.g., '0 6 * * *')")
        return v.strip()

    @field_validator("source_table", "target_table")
    @classmethod
    def _table_sanity(cls, v: str) -> str:
        v = v.strip()
        if "." not in v:
            raise ValueError("table must be in '<db>.<table>' format")
        return v

    @field_validator("partition_column")
    @classmethod
    def _col_sanity(cls, v: str) -> str:
        v = v.strip()
        if not v:
            raise ValueError("partition_column cannot be empty")
        return v


class BuildV2Request(BaseModel):
    """
    Build V2: UI sends a full spec (no need for copilot_spec.yaml).
    """
    spec: CopilotSpec
    # if True, we also write copilot_spec.yaml for visibility/debug (optional)
    write_spec_yaml: bool = True
    # allow callers to override workspace job name (rare)
    job_name_override: Optional[str] = None

    def resolved_job_name(self) -> str:
        return (self.job_name_override or self.spec.job_name).strip()


# Backward-compat alias: some endpoints/imports refer to BuildV2Spec
BuildV2Spec = BuildV2Request
